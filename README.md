# kpu-multimedia-real-time-exchange-system
한국공학대학교(한국산업기술대학교) 컴퓨터공학과 2021 UNIX시스템프로그래밍 설계과제<br>
3가지 IPC 기법(Shared Memory, Message Passing, Pipe)을 이용한 실시간/대용량 멀티미디어 파일 교환 시스템


# 문제 정의
1.	한 프로세스 당 여러 개의 스레드들을 이용하여 멀티미디어 파일 전송 작업을 효율적으로 처리한다.
2.	파일 전송 과정 중 여러 스레드들을 이용할 때 동기화 작업을 통해 파일의 같은 부분에 접근하는 경쟁상태에 빠지지 않도록 한다.
3.	서버와 클라이언트 프로세스 간의 통신으로 파일을 전송할 때 Advanced IPC기법이나 PIPE를 이용하여 처리한다.


# 설계 과제 목표
1.	클라이언트들끼리 서버를 거쳐 각종 대용량 멀티미디어 파일을 전송하는 응용 프로그램을 작성한다.
2.	수업시간에 배운 Advanced IPC 기법과 PIPE를 이용한 프로세스간 통신 방법을 이용하여 통신하는 서버와 클라이언트 프로세스의 구조를 만들고, 각 프로세스에서는 여러 스레드들 간에 동기화 기법을 잘 적용하여 경쟁상태에서 자유로운 상태로 각종 파일들을 서버를 거쳐 실시간으로 공유하는 응용 프로그램을 작성한다.
4.	설계 과제를 통해 Advanced IPC 기법, PIPE, 쓰레드 동기화 등의 고급 프로그래밍 기법들을 활용하여 응용 프로그램을 설계, 작성해 봄으로써 단순히 해당 기법들에 대한 이론과 실습 예제를 통한 학습에 그치는 것이 아니라 더 깊고 정확하게 이해하여 응용할 수 있으며 그에 따라 프로그램을 더 효율적으로 작성할 수 있다.

# 요구사항 분석
1.	각 클라이언트는 3개 이상의 스레드를 생성한다.
2.	클라이언트는 이미지 파일을 일정한 크기로 분할하여 버퍼에 저장한 뒤, 이를 서버로 전송한다.
3.	서버는 클라이언트로부터 전달된 데이터를 자신의 공간에 백업하고, 이를 다시 상대방에게 전송한다.
4.	각 클라이언트는 자신의 파일을 서버로 전송하고, 상대방의 파일을 수신 받는다.
5.	두 클라이언트가 서로 서버를 거쳐 보낸 파일이 원본을 유지하면서 전송이 완료되어야 한다.
6.	경쟁상태가 발생하지 않도록 synchronization tool을 활용한다.

# 시스템 설계
서버 프로세스와 연결된 각 클라이언트 프로세스는 초기에 상대 클라이언트에게 전달할 멀티미디어 데이터를 하나씩 가지고 있다. 해당 데이터는 프로세스가 가진 버퍼의 사이즈만큼 스레드에 의해 분할되어 IPC 기법을 통해 연결된 프로세스에게 전달된다. 서버는 양쪽의 클라이언트로부터 전달된 데이터를 버퍼의 크기만큼 받아들이고 이를 본인의 저장공간에 백업(저장)한다. 백업이 완료되면 서버는 다시 해당 파일을 읽어서 상대방에게 넘겨주는 작업을 수행하고, 자신의 데이터를 모두 보낸 클라이언트는 서버로부터 전달되는 데이터를 받아서 저장하는 것으로 프로그램의 동작이 마무리된다. 결과적으로 각 클라이언트 프로세스는 상대 클라이언트의 데이터를 저장하게 된다. 이러한 과정에서 공유 자원 등의 접근과 쓰레드 간의 실행 흐름을 제어하는 Synchronization Tool의 사용으로 프로그램의 성능을 높이는 구조를 가지도록 한다.

# 스레드 설계
## Shared Memory
- `void create_thread(void *, struct sh_use_st *)`
  - 스레드 생성 및 함수 실행,  종료 대기
- `void send_thread(struct sh_use_st *)`
  - 스레드를 이용하여 `send_file()` 함수 호출, 파일 송신 진행
- `void recv_thread(struct sh_use_st *)`
  - 스레드를 이용해 `recv_file()` 함수 호출, 파일 수신 진행

## Message Passing
- `thread_readFile_parent(void* msqid)`
   - 메시지 큐의 아이디를 기준으로 전송할 클라이언트에게 보낼 버퍼를 저장
- `thread_readFile_child()`
   - 각 자식 프로세스가 부모 프로세스에게 보낼 버퍼를 저장

## Pipe
- `sendThread(void* arg)`
  - 프로세스가 가지고 있는 데이터를 읽고 arg로 넘겨 받은 파이프를 통해 송신
- `recvThread(void* arg)`
  - 프로세스가 가지고 있는 데이터를 arg로 넘겨 받은 파이프로 수신 및 저장
- `waitThread(void* arg)`
  - 데이터를 읽을 수 있는 상황이 될 때까지 기다림
  - 상대방의 데이터가 서버에 백업되기 전에 서버로부터 해당 데이터를 읽는 것을 시도하는 경우를 방지

# 공유 자원 정의 및 동기화 기법 설계
## Shared Memory
- `struct sh_use_st * shmsg`라는 공유 메모리 구조체 변수를 만들어 사용
- 구조체 내부에는 id값, 주소 값과 각종 플래그 변수, 뮤텍스 변수가 존재함
- `pthread_mutex_lock()`, `pthread_mutex_unlock()`을 이용하여 파일을 공유 메모리 변수의 동시 접근 제어

## Message Passing
- 각 스레드는 동일한 파일을 읽어야 하기 때문에 파일 포인터를 공유 자원으로 설정
- `pthread_mutex_lock()`과 `pthread_mutex_unlock()`을 활용하여 한 순간에 하나의 스레드만 공유자원에 접근하도록 설정

## Pipe
- flag라는 공유 변수를 프로세스가 공유하여 각 프로세스의 실행 시점을 조정. 서버가 상대방의 데이터를 백업하지 못한 상황에서 데이터를 읽어 들이려고 하거나 클라이언트가 데이터를 전송하고 있지 않은 상황에 서버가 먼저 데이터를 읽고 종료하는 경우를 방지
- flag에 동시 접근을 못하도록 Mutex라는 Synchronization tool을 사용
- 프로그램 실행 후 사용한 공유 자원은 필요 없으므로 해제 코드를 삽입

# 데모 시나리오
- A와 B 두 사람이 서로가 가지고 있는 멀티미디어 데이터(이미지 파일)을 서로 교환하기 위해 서버에 접속한다.
- 두 사람은 리눅스 환경에서 서버에 동시에 접속하여 파일을 전송한다.
- 사용자들은 자신과 연결된 서버에 자신의 파일을 백업해 놓고, 서버는 사용자들이 백업한 데이터를 다시 읽어서 다른 사용자에게 전송한다.
- 모든 과정을 거쳐 전달된 데이터(이미지)가 제대로 전달되었는지 파일의 크기를 확인하고, scp 명령어를 이용하여 Windows 환경에서 이미지가 제대로 표현되는지 확인한다.

# 소스코드
## Shared Memory
- 소스파일
  - server.c client1.c client2.c header.h header.c
- 실행파일
  - server.out client1.out client2.out
## Message Passing
- 소스파일
  - message_passing.c , unix_header.h
- 실행파일
  - ./message_passing
## Pipe
- 소스파일
  - pipe.c pipe_header.h
- 실행파일
  - ./pipe

# 컴파일 및 실행방법
`make` 명령을 통해 컴파일

## Shared Memory
1. `make` 명령어로 컴파일
2.  `./server.out` 명령어로 서버 실행 후 `./client1.out`, `./client2.out` 명령어로 클라이언트 실행.
3.  클라이언트 두개 모두 실행되면 서버에서 엔터키 입력<br>
     `make clean` 입력 시 `make` 명령어로 생성된 오브젝트 파일, 실행 파일 삭제<br>
     `make clean_datas` 입력 시 프로그램 실행하여 생성된 백업파일, 전송파일 삭제

## Message Passing
1. `./message_passing` 명령으로 실행
2. `make clean` 수행 시 `make` 컴파일로 만들어진 파일 삭제

## Pipe
1. `./pipe` 명령으로 실행
2. `make clean` 명령 수행 시 `make` 컴파일로 만들어진 파일 삭제
